<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://hazuki.cn/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://hazuki.cn/atom.xml"><link rel="alternate" type="application/json" href="https://hazuki.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/css/app.css?v=0.2.5"><meta name="keywords" content="计算机组成原理"><link rel="canonical" href="https://hazuki.cn/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/"><title>Chapter 1 Computer Abstractions and Technology - 计算机组成原理 - 计算机科学 | Hazuki の 小屋 = = 葉月書架</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Chapter 1 Computer Abstractions and Technology</h1><div class="meta"><span class="item" title="创建时间：2021-12-29 17:55:29"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-12-29T17:55:29+08:00">2021-12-29</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hazuki の 小屋</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/deef1a0cly8gy11cqpw4zj21e00u0n6s.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/deef1a0cly8gy127iwzngj21hc0u0126.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/deef1a0cly8gy0yihkpsej21e00u07at.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/deef1a0cly8gy0wt2eo0lj21hc0u0qb4.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/deef1a0cly8gy122s02qbj20yt0u0gro.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/deef1a0cly8gy12epa39jj21he0u0wog.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/computer-organization/" itemprop="item" rel="index" title="分类于 计算机组成原理"><span itemprop="name">计算机组成原理</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hazuki.cn/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/images/avatar.jpg"><meta itemprop="name" content="Hazuki 叶月"><meta itemprop="description" content="葉月書架, 计算机基础 & 编程笔记"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记和习题整理<br>书籍：计算机组成与设计：软 / 硬件接口 (Computer Organization And Design: The Hardware/Software Interface)、计算机系统基础（第 2 版 袁春风）<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFhNHkxajd4aw==">https://www.bilibili.com/video/BV1qa4y1j7xk</span></p></div><h1 id="概述"><a class="anchor" href="#概述">#</a> 概述</h1><div class="note primary no-icon"><p>The <code class="blue">most beautiful thing</code> we can experience is the <code class="pink">mysterious</code> . It is the <code class="aqua">source</code> of all true art and science. —— Albert Einstein, <em>What I Believe</em>, 1930</p><ul><li>我们能体验的最美好的事情是<span class="pink">神秘</span>。它是一切真正的艺术和科学的<span class="aqua">源泉</span>。 —— 阿尔伯特・爱因斯坦，《我的信仰》，1930</li></ul></div><h2 id="关于本书"><a class="anchor" href="#关于本书">#</a> 关于本书</h2><p>我们认为，在 <code class="blue">计算机科学和工程</code> (computer science and engineering) 中的学习应该反映该领域 <code class="red">当前的状态</code> ，并介绍形成、塑造计算的那些原理。我们还认为，计算机各专业的读者都需要理解决定 <code class="aqua">计算机系统</code> 的 <code class="orange">能力 (capabilities)</code> 、 <code class="purple">性能 (performance)</code> 、 <code class="cyan">能耗(energy)</code> 以及最终的成功的 <code class="pink">组成范式 (organizational paradigms)</code> 。</p><details class="success"><summary>Wikipedia: Paradigm</summary><div><p>In science and philosophy, a paradigm (/ˈpærədaɪm/) is a distinct set of <code class="red">concepts</code> or <code class="blue">thought patterns</code> , including theories, research methods, postulates, and standards for what constitutes legitimate contributions to a field.</p><ul><li>在科学和哲学中，范式是一套独特的 <code class="red">概念</code> 或 <code class="blue">思维模式</code> ，包括理论、研究方法、假设和对某一领域作出合理贡献的标准。</li></ul></div></details><ul><li><p>现代计算机技术要求每一个计算机专业的专业人员都要同时了解 <code class="blue">硬件</code> 和 <code class="pink">软件</code> 。不同层次的硬件和软件之间的 <code class="aqua">交互</code> 也为理解计算的基本原理提供了一个框架。无论你的主要兴趣是硬件还是软件，计算机科学还是电气工程， <code class="purple">计算机组成和设计</code> 的中心思想都是相同的。因此，本书的重点是展示硬件和软件之间的关系，并着重介绍当今计算机中的基础概念。</p><div class="note info no-icon"><p>最近从 <code class="blue">单处理器 (uniprocessor)</code> 到 <code class="red">多核微处理器 (multicore microprocessors)</code> 的转变证实了这个观点的正确性，这是第一版以来给出的。虽然程序员可以忽略这些建议，而依靠计算机架构师、编译器作者和芯片工程师来让他们的程序运行得更快或更节能，而不修改程序，但<span class="red">那个时代已经结束了</span>。为了使程序运行得更快，它们必须成为 <code class="pink">并行的 (parallel)</code> 。虽然许多研究人员的目标是让程序员可以不考虑他们正在编程的硬件的底层并行特性，但要实现这一愿景还需要很多年。我们的观点是，至少在接下来的十年里，如果想让程序在 <code class="purple">并行计算机</code> 上高效运行，大多数程序员将不得不理解 <code class="aqua">硬件/软件接口</code> 。</p></div></li></ul><p>这本书的受众包括那些：在 <code class="blue">汇编语言 (assembly language)</code> 或 <code class="red">逻辑设计 (logic design)</code> 方面缺乏经验、需要理解基本的 <code class="cyan">计算机组成</code> 的人，以及具有汇编语言和 / 或逻辑设计背景，想要学习 <code class="purple">如何设计一个计算机</code> 或 <code class="aqua">理解系统如何工作</code> 以及为什么它这样运行的读者。</p><div class="note success no-icon"><p>欢迎阅读这本书！我们很高兴有这个机会来传达 <code class="blue">计算机系统 (computer systems)</code> 世界的激动人心之处。这不是一个枯燥沉闷、进步缓慢、新思想因忽视而萎缩的领域。不是！计算机是令人难以置信的充满活力的<span class="red">信息技术产业 (information technology industry)</span> 的产物，信息技术产业的各个方面几乎占美国国民生产总值的 10%，而美国的经济在一定程度上依赖于 <code class="aqua">摩尔定律 (Moore’s Law)</code> 所承诺的信息技术的快速进步。这是一个非同寻常的行业，它以惊人的速度拥抱创新。</p></div><h2 id="计算应用的分类及其特性"><a class="anchor" href="#计算应用的分类及其特性">#</a> 计算应用的分类及其特性</h2><div class="note primary"><p>从 <code class="aqua">智能家电</code> 到 <code class="pink">手机</code> 再到最大的 <code>超级计算机</code> ，它们虽然都使用一组 <code class="blue">通用的硬件技术</code> （见章节 1.4 和 1.5），但这些不同的应用有不同的 <code class="red">设计需求</code> ，并以不同的方式使用核心硬件技术。</p></div><p>广义地说，计算机用于三类不同的应用：</p><ol><li><p><strong class="blue">个人电脑 (Personal computers, PCs)</strong>：可能是最广为人知的计算形式，本书的读者可能已经广泛使用。</p><ul><li>个人电脑强调以低成本向 <code class="red">单个用户</code> 提供良好的性能，通常运行 <code class="aqua">第三方软件</code> 。</li><li>这类计算推动了许多计算技术的发展，而这些技术只有大约 35 年的历史！</li></ul></li><li><p><strong class="red">服务器 (Servers)</strong>：曾经大得多的计算机的现代形式，通常只能 <code class="blue">通过网络访问</code> 。</p><ul><li><p>服务器是面向 <code class="purple">承载大型工作负载</code> 的。这些负载可以是由 <code class="pink">单个复杂的应用</code> 组成的，通常是科学或工程应用，也可以是处理 <code class="aqua">许多小型工作</code> 的，例如在构建一个大型的 web 服务器时发生的工作。</p><div class="note success"><p>这些应用通常基于 <code class="aqua">来自其他来源的软件</code> （如数据库或模拟系统），但通常会针对特定功能进行修改或定制。</p></div></li><li><p>服务器采用与桌面计算机 <code class="red">相同的基本技术</code> ，但提供更大的计算、存储和输入 / 输出能力。</p></li><li><p>一般来说，服务器也更重视 <code class="cyan">可靠性</code> ，因为崩溃的代价通常比单用户 PC 更高。</p></li></ul><div class="note info no-icon"><p><span class="red">服务器</span> 在 <span class="blue">成本和能力</span> 上的差异最大：</p><ul><li>在低端，一台服务器可能比一台 <code class="aqua">没有屏幕或键盘的桌面计算机</code> 多一点，价格为 1000 美元。这些低端服务器通常用于文件存储、小型商业应用或简单的 web 服务（见章节 6.10）。</li><li>另一个极端是 <code class="pink">超级计算机</code> ，目前由数万个处理器和许多 TB 的内存组成，成本高达数千万到数亿美元。超级计算机通常用于高端的 <code class="blue">科学和工程计算</code> ，如天气预报、石油勘探、蛋白质结构测定和其他大规模问题。尽管这类超级计算机代表了 <code class="red">计算能力的顶峰</code> ，但它们只占服务器和整个计算机市场收入的相对较小的一部分。</li></ul></div><details class="primary"><summary>Terminology: terabyte</summary><div><p><strong class="blue">terabyte (TB)</strong>: Originally 1,099,511,627,776 ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> ) bytes, although <code class="aqua">communications</code> and <code>secondary storage systems</code> developers started using the term to mean 1,000,000,000,000 ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> ) bytes.</p><ul><li><p>To reduce confusion, we now use the term <code class="blue">tebibyte (TiB)</code> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> bytes, defining <code class="pink">terabyte (TB)</code> to mean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> bytes.</p></li><li><p>Figure 1.1 shows the full range of <code class="pink">decimal</code> and <code class="cyan">binary</code> values and names.</p><p><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_0.png" alt="Untitled_0" width="700px"></p></li></ul></div></details></li><li><p><strong class="aqua">嵌入式计算机 (Embedded computers)</strong>：计算机中 <code class="blue">规模最大</code> 、应用和性能范围最广的一类。嵌入式计算机包括汽车中的微处理器、电视机中的计算机，以及控制现代飞机或货船的 <code class="brown">处理器网络 (networks of processors)</code> 。</p><ul><li><p>嵌入式计算系统的设计目的是运行一个或一组相关的应用程序，这些应用程序通常 <code class="red">与硬件集成</code> 并作为单个系统交付给用户。因此，尽管有大量的嵌入式计算机，大多数用户从来没有真正看到他们正在使用计算机！</p><div class="note info no-icon"><p><span class="aqua">Embedded computer</span>: A computer <code class="blue">inside another device</code> used for running <code class="red">one predetermined application</code> or <code class="aqua">collection of software</code> .</p><ul><li>嵌入式计算机：一个存在于另一个设备中的计算机，用于运行一个预先定义的应用程序，或一组软件。</li></ul></div></li><li><p>嵌入式应用通常有独特的应用需求，这些需求结合了 <code class="cyan">最低性能</code> 和 <code class="aqua">严格的成本或功耗限制</code> 。例如，考虑一个音乐播放器：处理器只需要尽可能快地处理其 <code class="red">有限的功能</code> ，除此之外，最大限度地 <code class="grey">降低成本和功耗</code> 是最重要的目标。</p></li></ul><div class="note primary"><p>尽管价格低廉，嵌入式计算机 <code>对故障的容忍度</code> 往往较低，因为其结果可能从令人沮丧到破坏性不等。</p><ul><li>在 <code class="cyan">面向消费者</code> 的嵌入式应用中，例如数字家电，可靠性主要是通过 <code class="red">简单设计 (simplicity)</code> 实现的，重点是尽可能完美地完成 <code class="blue">一个功能</code> 。</li><li>在 <code class="aqua">大型嵌入式系统</code> 中，经常使用来自 <code class="pink">服务器领域</code> 的冗余技术。</li></ul></div><p>虽然这本书的重点是通用计算机，大多数概念可直接或者稍微修改之后用于嵌入式计算机。</p><details class="info"><summary>Elaboration: processor cores</summary><div><p>Many <span class="blue">embedded processors</span> are designed using <code class="pink">processor cores</code> , a version of a processor written in a <span class="red">hardware description language</span>, such as Verilog or VHDL (see Chapter 4). The core allows a designer to integrate other <span class="aqua">application-specific hardware</span> with the processor core for fabrication on a single chip.</p><ul><li>许多 <code class="blue">嵌入式处理器</code> 都是使用 <code class="pink">处理器核</code> 设计的，处理器内核是用 <code class="red">硬件描述语言</code> 编写的处理器版本（如 Verilog 或 VHDL，见第 4 章）。处理器核允许设计者将其他 <code class="aqua">特定于应用程序的硬件</code> 集成到处理器核中，以便在单个芯片上制造。</li></ul></div></details></li></ol><h2 id="欢迎来到后pc时代"><a class="anchor" href="#欢迎来到后pc时代">#</a> 欢迎来到后 PC 时代</h2><div class="note info"><p>技术的持续进步带来了 <code class="blue">计算机硬件</code> 的 <code class="red">代际变化</code> ，撼动了整个信息技术产业。自上一版以来，我们经历了如此重大的变化，就像 30 年前开始转向个人电脑一样。</p></div><ol><li><p>代替 <span class="blue">PC</span> 的是 <strong class="blue">个人移动设备 (PMD, personal mobile device)</strong>。PMD 由电池供电，通过无线方式连接到互联网，通常需要花费数百美元，并且像个人电脑一样，用户可以下载 <code class="red">软件 (“apps”)</code> 来运行它们。</p><ul><li>与个人电脑不同的是，它们不再有键盘和鼠标，而更有可能依赖于触摸屏，甚至语音输入。</li><li>今天的 PMD 是 <code class="blue">智能手机</code> 或 <code class="aqua">平板电脑</code> ，但明天它可能包括电子眼镜。</li></ul></li><li><p>取代传统 <span class="red">服务器</span> 的是 <strong class="red">云计算 (Cloud Computing)</strong>，它依赖于大型 <code class="blue">数据中心</code> ，这些数据中心现在被称为 <code class="red">仓储规模计算机</code> (WSCs, Warehouse Scale Computers)。</p><ul><li>像 Amazon 和谷歌这样的公司构建了包含 10 万台服务器的 WSC，然后让一些公司可以 <code class="brown">租用</code> 其中的一部分，这样他们就可以向 PMD 提供 <code class="pink">软件服务</code> ，而不必自己构建 WSC。</li><li>事实上，通过云部署的 <code class="cyan">软件即服务 (SaaS, Software as a Service)</code> 正在彻底改变软件行业，就像 PMD 和 WSC 正在彻底改变硬件行业一样。今天的软件开发人员通常会让他们的应用程序的一部分 <code class="aqua">运行在 PMD 上</code> ，另一部分 <code class="red">运行在云上</code> 。</li></ul><div class="note primary"><p>软件即服务 (SaaS)：通过互联网 <code>以服务的形式</code> 提供 <code class="red">软件</code> 和 <code class="blue">数据</code> ，通常是通过运行在本地客户端设备上的 <code class="purple">浏览器</code> 等小的程序，而不是在该设备上运行所有的二进制代码（一部分在服务器端执行）。例如网络搜索和社交网络。</p></div></li></ol><h2 id="你能从本书学到什么"><a class="anchor" href="#你能从本书学到什么">#</a> 你能从本书学到什么</h2><div class="note info no-icon"><p>成功的程序员总是关心其程序的 <code class="blue">性能 (performance)</code> ，因为让用户 <code class="red">快速得到结果</code> 对软件成功与否至关重要。</p><ul><li><p>在 20 世纪 60 年代和 70 年代，计算机性能的一个主要限制是计算机 <code class="cyan">内存的大小</code> 。因此，程序员通常遵循一个简单的信条： <code class="brown">最小化占用的内存空间</code> 以使程序更快。</p></li><li><p>在过去的十年里， <code class="pink">计算机设计</code> 和 <code class="blue">存储器技术</code> 的进步 <code class="aqua">大大降低了</code> 少占内存容量在大多数应用中的重要性，除了嵌入式计算系统中的应用。</p></li></ul></div><ul><li><p>对性能感兴趣的程序员现在需要理解已经 <span class="red">取代</span> 20 世纪 60 年代 <span class="grey">简单内存模型</span> 的事物： <code class="red">处理器的并行特性</code> 和 <code class="blue">内存的层次特性</code> 。</p></li><li><p>此外，当今的程序员需要考虑运行在 PMD 或云上的程序的 <code class="aqua">能耗效率 (energy efficiency)</code> ，这就要求他们了解自己 <code class="purple">代码之下</code> 的许多细节（见 1.7 节）。</p></li></ul><p>因此，程序员为了构建 <code class="cyan">具有竞争力</code> 的软件版本，必须增加他们对 <code class="pink">计算机组成</code> 的认识。</p><p>我们很荣幸有机会为你解释这台革命性机器 — <code class="aqua">计算机</code> 的内部结构，解开 <code class="blue">程序之下的软件</code> 以及 <code class="red">计算机外壳下的硬件</code> 。</p><details class="info"><summary>Understanding Program Performance</summary><div><p>The <span class="red">performance</span> of a <span class="blue">program</span> depends on a combination of</p><ul><li>the <code class="pink">effectiveness of the algorithms</code> used in the program,</li><li>the <code class="aqua">software systems</code> used to create and translate the program into <code class="orange">machine instructions</code> , and</li><li>the <code class="blue">effectiveness of the computer</code> in executing those instructions, which may include <code class="purple">input/output (I/O) operations</code> .</li></ul><p>This table summarizes how the <span class="blue">hardware</span> and <span class="pink">software</span> affect performance.</p><table><thead><tr><th>Hardware or software component</th><th>How this component affects performance</th><th>Where is this topic covered?</th></tr></thead><tbody><tr><td><span class="red">Algorithm</span></td><td>Determines both the number of <code class="blue">source-level statements</code> and the number of <code class="purple">I/O operations</code> executed</td><td>Other books!</td></tr><tr><td><span class="aqua">Programming language, compiler, and architecture</span></td><td>Determines the number of <code class="orange">computer instructions</code> for each source-level statement</td><td>Chapters 2 and 3</td></tr><tr><td><span class="blue">Processor and memory system</span></td><td>Determines <code class="blue">how fast instructions</code> can be executed</td><td>Chapters 4, 5, and 6</td></tr><tr><td><span class="purple">I/O system (hardware and operating system)</span></td><td>Determines <code class="purple">how fast I/O operations</code> may be executed</td><td>Chapters 4, 5, and 6</td></tr></tbody></table></div></details><h1 id="计算机体系结构中的八个伟大思想"><a class="anchor" href="#计算机体系结构中的八个伟大思想">#</a> 计算机体系结构中的八个伟大思想</h1><div class="note primary"><p>现在我们介绍 <code class="blue">计算机架构师 (computer architects)</code> 在过去 60 年的计算机设计中提出的 8 个 <code class="red">伟大思想 (great ideas)</code> 。这些思想是如此强大，以至于在首台应用它们的计算机出现之后的很长时间里，新的架构师们通过 <code class="aqua">模仿他们的前辈</code> 来表达钦佩之情。这些伟大思想将是我们将在本章和后续章节中穿插的主题。为了指出它们的影响，在本节中，我们将介绍代表伟大思想的图标和突出显示的术语，并使用它们来指出这本书中近 100 个以使用这些伟大思想为特色的小节。</p></div><table><thead><tr><th>Great idea</th><th>Description of the Great idea</th><th>Description of the icon</th><th>icon</th></tr></thead><tbody><tr><td><span class="blue">面向摩尔定律设计（Design for Moore’s Law）</span></td><td>计算机设计者面临的一个永恒的问题就是主要由 <code class="blue">摩尔定律 (Moore’s Law)</code> 所驱动的<span class="purple">快速变化</span>。摩尔定律指出，<span class="red">单芯片上的集成度</span>每 18-24 个月翻一番。摩尔定律源于 Intel 创始人之一 Gordon Moore 在 1965 年对集成电路集成度的增长做出的预测。由于<span class="aqua">计算机设计</span>可能需要<span class="orange">数年时间</span>，因此在项目结束时，单芯片的集成度相对于设计开始时很容易翻一番甚至翻两番。就像双向飞碟射击者一样，计算机架构师们必须预测其<span class="red">设计完成时的工艺水平</span>，而不是设计开始时的。</td><td>我们使用 “向上和向右” 的<span class="blue">摩尔定律图</span>来代表<span class="red">面向快速变化</span>的设计。</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_2.png" alt="Untitled_2" width="200px"></td></tr></tbody><tbody><tr><td><span class="red">使用抽象简化设计（Use Abstraction to Simplify Design）</span></td><td>计算机架构师和程序员都必须发明技术来<span class="blue">提高自己的工作效率</span>，否则根据摩尔定律，设计时间会像资源增长一样急剧延长。硬件和软件的主要生产力技术是使用 <code class="red">抽象</code> 来表示<span class="aqua">不同层次的设计</span>；<span class="pink">隐藏较低层次的细节</span>，以便在较高层次上提供更简单的模型。</td><td>我们将使用<span class="cyan">抽象绘画</span>图标来表示第二个伟大的想法。</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_3.png" alt="Untitled_3" width="200px"></td></tr></tbody><tbody><tr><td><span class="aqua">使得常见情况快速处理（Make the Common Case Fast）</span></td><td>使得 <code class="blue">常见情况</code> 快速处理比<span class="purple">优化罕见情况</span>更能提高性能。具有讽刺意味的是，常见的情况通常比罕见的情况更简单，因此通常更容易增强。这个常识性建议意味着你<span class="red">知道常见的情况是什么</span>，这只有通过仔细的<span class="blue">实验和测量</span>才能实现（见第 1.6 节）。</td><td>我们用<span class="aqua">一辆跑车</span>作为使得常见情况快速处理的图标，因为最常见的旅行有一到两个乘客，当然，制造一辆快速的跑车比一辆快速的小型货车更容易！</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_4.png" alt="Untitled_4" width="200px"></td></tr></tbody><tbody><tr><td><span class="purple">通过并行提高性能（Performance via Parallelism）</span></td><td>自从计算机出现以来，计算机架构师们已经提供了通过<span class="blue">并行执行操作 (performing operations in parallel)</span> 来获得更高性能的设计。在这本书中，我们会看到许多并行的例子。</td><td>我们使用一架飞机的<span class="orange">多个喷气发动机</span>作为 <code class="red">并行性能</code> 的图标。</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_5.png" alt="Untitled_5" width="200px"></td></tr></tbody><tbody><tr><td><span class="blue">通过流水线提高性能（Performance via Pipelining）</span></td><td>在计算机体系结构中，有一种<span class="red">特殊的并行模式</span>如此流行，以至于它值得拥有自己的名字： <code class="blue">流水线 (pipelining)</code> 。例如许多西部片中，一些坏人在制造火灾，在消防车出现之前会有一个 “救火队列” 负责灭火：村民们<span class="aqua">组成一个人链</span>来携带水源至火场，因为他们可以更快地<span class="orange">沿着链上移动水桶</span>，而不是每个人都在来回奔跑。</td><td>我们的流水线图标是一个<span class="blue">管道序列</span>，每个部分代表流水线的一个阶段。</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_6.png" alt="Untitled_6" width="200px"></td></tr></tbody><tbody><tr><td><span class="red">通过预测提高性能（Performance via Prediction）</span></td><td>正如谚语<span class="pink"> “求人准许不如求人原谅”</span> 所说，最后一个伟大的想法是 <code class="blue">预测</code> ：在某些情况下，假设<span class="aqua">从错误预测中恢复的机制</span>代价并不太高，并且你的<span class="purple">预测相对准确</span>，那么<span class="red">猜测并开始工作</span>比<span class="grey">等到确定之后再进行工作</span>要快得多。</td><td>我们用<span class="red">算命师的水晶球</span>作为我们预测的图标。</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_7.png" alt="Untitled_7" width="200px"></td></tr></tbody><tbody><tr><td><span class="aqua">存储器的层次结构（Hierarchy of Memories）</span></td><td>程序员希望内存快、大、便宜，因为<span class="cyan">内存速度</span>通常<span class="red">决定性能</span>，容量限制了<span class="blue">可以解决的问题的大小</span>，而内存的成本通常是计算机成本的主要部分。架构师发现，他们可以通过 <code class="red">存储器的层次结构</code> 来解决这些冲突的需求，在层次结构的顶部使用最快、最小和每比特价格最昂贵的存储器，而在底层使用最慢、最大和每比特价格最便宜的存储器。正如我们将在第 5 章中看到的，<span class="blue">高速缓存 (caches)</span> 给程序员一种<span class="orange">错觉</span>，即<span class="pink">主存</span>几乎和层次结构顶部的存储器一样快，并和层次结构底部的存储器一样大，一样便宜。</td><td>我们使用一个<span class="orange">分层的三角形</span>图标来表示存储器的层次结构。形状表示着速度，成本和大小：越接近顶部的，是更快和每比特价格更昂贵的存储器；底部越宽，存储器越大。</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_8.png" alt="Untitled_8" width="200px"></td></tr></tbody><tbody><tr><td><span class="cyan">通过冗余提高可靠性（Dependability via Redundancy）</span></td><td>计算机不仅需要速度快，还需要工作可靠。由于任何物理设备都可能发生故障，因此我们通过 <code class="red">包含冗余组件</code> 来确保系统的<span class="blue">可靠性</span>，这些冗余组件可以在故障发生时<span class="orange">替代失效部件</span>，并可以<span class="aqua">帮助检测故障</span>。</td><td>我们使用<span class="aqua">牵引车</span>作为我们的图标，因为它的后轴两侧各有两个轮胎，即使一个轮胎坏了，卡车也可以继续行驶。（据推测，卡车司机会立即前往维修厂修理漏气的轮胎，从而恢复冗余！）</td><td><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_9.png" alt="Untitled_9" width="200px"></td></tr></tbody></table><h1 id="程序之下的软件below-your-program"><a class="anchor" href="#程序之下的软件below-your-program">#</a> 程序之下的软件（Below Your Program）</h1><div class="note primary"><p>一个典型的 <code class="blue">应用程序</code> （如字处理程序、大型数据库系统）可以由 <code class="aqua">数百万行代码</code> 构成，并依赖于实现复杂功能的 <code class="red">软件库 (software libraries)</code> 来支持应用程序。</p><ul><li>正如我们将看到的，计算机中的 <code class="orange">硬件</code> 只能执行极其简单的 <code class="blue">低级指令 (low-level instructions)</code> 。</li><li>从 <code class="pink">复杂的应用程序</code> 到 <code class="blue">简单的指令</code> ，需要调用 <code class="red">几个层次的软件</code> 来将这些 <code class="aqua">高级操作 (high-level operations)</code> ， <code class="blue">解释 (interpret)</code> 或 <code class="red">翻译 (translate)</code> 为简单的计算机指令。而这是 <code class="aqua">伟大思想</code> 中的 <code class="red">抽象</code> 的一个的例子。</li></ul></div><ol><li><p>如图所示，这些 <code class="red">软件层</code> 主要以 <code class="aqua">分层的方式</code> 组织，其中 <code class="blue">应用程序 (applications)</code> 位于最外层的环，而各种 <code class="red">系统软件 (systems software)</code> 则位于硬件和应用软件之间。</p><p><img data-src="/assets/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/Untitled_10.png" alt="Untitled_10" width="600px"></p><div class="note info no-icon"><p><span class="red">systems software</span>: Software that provides services that are <code class="blue">commonly useful</code> , including <code class="purple">operating systems</code> , <code class="red">compilers</code> , <code class="orange">loaders</code> , and <code class="aqua">assemblers</code></p><ul><li>系统软件：提供 <code class="blue">常用服务</code> 的软件，包括 <code class="purple">操作系统</code> 、 <code class="red">编译器</code> 、 <code class="orange">加载器</code> 和 <code class="aqua">汇编器</code> 。</li></ul></div></li><li><p>有许多类型的 <code class="red">系统软件</code> ，但其中有两种类型的系统软件是当今每个 <code class="cyan">计算机系统的中心</code> ： <code class="purple">操作系统</code> 和 <code class="red">编译器</code> 。</p><ol><li><p><span class="purple">操作系统 (operating system)</span>：是 <code class="blue">用户程序</code> 和 <code class="orange">硬件</code> 之间的接口，提供各种 <code class="aqua">服务</code> 和 <code class="brown">监控功能 (supervisory functions)</code> 。其中最重要的功能是：</p><ul><li>处理基本的<span class="aqua">输入和输出操作</span></li><li><span class="red">分配存储和内存</span></li><li>在同时使用计算机的<span class="blue">多个应用程序</span>之间提供受保护的<span class="pink">计算机共享资源</span>。</li></ul><p>当前我们使用的操作系统的例子有 Linux、iOS 和 Windows。</p><div class="note primary no-icon"><p><span class="purple">operating system</span>: <code class="blue">Supervising program</code> that <code class="red">manages the resources</code> of a computer for the benefit of the programs that run on that computer.</p><ul><li>操作系统：为使计算机上运行的程序受益而管理 <code class="red">计算机资源</code> 的 <code class="blue">监督程序</code> 。</li></ul></div></li><li><p><span class="red">编译器 (compiler)</span>：执行另一个重要的功能：将用 <code class="aqua">高级语言</code> （如 C、C++ 或 Java）编写的程序，翻译成硬件可以执行的 <code class="cyan">指令</code> 。</p><ul><li>由于 <code class="pink">现代编程语言</code> 的复杂性和 <code class="blue">硬件所执行的指令</code> 的简单性，从高级语言程序到硬件指令的转换是复杂的。</li><li>我们在这里简要概述这个过程，然后在第二章和附录 A 中进行更深入的讨论。</li></ul><div class="note info no-icon"><p><span class="blue">compiler</span>: A program that translates <code class="pink">high-level language statements</code> into <code class="cyan">assembly language statements</code> .</p><ul><li>编译器：把 <code class="pink">高级语言语句</code> 翻译成 <code class="cyan">汇编语言语句</code> 的程序。</li></ul></div></li></ol></li></ol><h2 id="从高级语言到硬件语言"><a class="anchor" href="#从高级语言到硬件语言">#</a> 从高级语言到硬件语言</h2><h3 id="位和指令"><a class="anchor" href="#位和指令">#</a> 位和指令</h3><div class="note primary"><p>想要真正地与 <code class="pink">电子硬件 (electronic hardware)</code> 对话，你需要发送 <code class="blue">电子信号 (electrical signals)</code> 。</p><ul><li>计算机最容易理解的信号是 <code class="cyan">开和关 (on and off)</code> ，所以 <code class="aqua">计算机的字母表</code> 只有 <code class="red">两个字母</code> 。</li><li>就像 <code class="purple">英语字母表</code> 中的 26 个字母并不限制我们可以写多少一样，计算机字母表中的两个字母也不限制 <code class="purple">计算机能够做什么</code> 。</li></ul></div><ol><li><p>这 <code class="brown">两个字母</code> 的两个符号表示是数字 <code class="brown">0</code> 和 <code class="brown">1</code> ：</p><ul><li>我们通常将 <code class="cyan">计算机语言 (computer language)</code> 认为是 <span class="purple">以 2 为基数的数字 (numbers in base 2)</span>，或称 <strong class="purple">二进制数 (binary numbers)</strong>。</li><li>我们把每个 <code class="aqua">“字母” (letter)</code> 称为一个 <span class="blue">二进制数字 (binary digit)</span> 或 <strong class="blue">位 (bit)</strong>。</li></ul><div class="note info no-icon"><p><span class="blue">binary digit</span> : Also called a <code class="cyan">bit</code> . One of the two numbers in <code class="brown">base 2 (0 or 1)</code> that are the <code class="red">components of information</code> .</p><ul><li>二进制数字：也称一个<span class="cyan">位</span>。<span class="brown">以 2 为基数 (0 或 1)</span> 的两个数字之一，它们是<span class="red">构成信息的组件</span>。</li></ul></div></li><li><p>计算机是我们的<span class="red">命令的奴隶 (slaves to our commands)</span>，这些命令被称为 <strong class="cyan">指令 (instructions)</strong>。</p><ul><li>这些指令，也不过是 <span class="blue">位的集合体 (collections of bits)</span>，由计算机所理解和遵守，可以被认为是 <code class="aqua">数字 (numbers)</code> 。</li><li>例如，位的集合 <code class="brown">1000110010100000</code> ，让一台计算机将两个数字相加。</li></ul><details class="primary"><summary>Chapter 2: using numbers for both instructions and data</summary><div><p>在第二章中，我们解释了为什么使用 <code class="aqua">数字</code> 来表示 <code class="blue">指令</code> 和 <code class="red">数据</code> 。</p><ul><li>我们不想抢了这一章的风头，但指令和数据<span class="cyan"> “都使用数字表示”</span> 是计算的基础。</li></ul></div></details><div class="note primary no-icon"><p><span class="cyan">instruction</span> : A <code class="red">command</code> that <code class="blue">computer hardware</code> understands and obeys.</p><ul><li>指令：<span class="blue">计算机硬件</span>所理解和遵守的<span class="red">命令</span>。</li></ul></div></li></ol><h3 id="汇编语言"><a class="anchor" href="#汇编语言">#</a> 汇编语言</h3><div class="note info"><p>最初的第一批程序员用 <code class="blue">二进制数</code> 与计算机交流，但这太乏味了。于是他们很快发明了 <code class="aqua">更接近人类思维方式</code> 的新符号。</p><ul><li>起初，这些符号是<span class="cyan">手工转换</span>成二进制的，但是这个过程仍然很累人。</li><li>于是，先驱们<span class="red">利用计算机</span>帮助编写<span class="aqua">计算机程序</span>，发明了将 <code class="purple">符号表示法</code> 转换成 <code class="blue">二进制</code> 的一些 <code class="pink">程序</code> 。</li></ul></div><ol><li><p>这些程序中的第一个被称为 <strong class="red">汇编器 (assembler)</strong>。这个程序将 <code class="red">指令</code> 的 <code class="aqua">符号版本</code> 转换成 <code class="blue">二进制版本</code> 。例如，程序员会写</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>add A,B</pre></td></tr></table></figure><p>而汇编器会把这个符号转换成</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1000110010100000</span></pre></td></tr></table></figure><p>这条指令告诉计算机将两个数字 A 和 B 相加。</p><div class="note primary no-icon"><p><span class="red">assembler</span> : A program that translates a <code class="aqua">symbolic version</code> of <code class="red">instructions</code> into the <code class="blue">binary version</code> .</p><ul><li>汇编器：把 <span class="red">指令</span> 的 <span class="aqua">符号版本</span> 转换成 <span class="blue">二进制版本</span> 的程序。</li></ul></div></li><li><p>为这种 <code class="purple">符号语言 (symbolic language)</code> 创造的名字至今仍在使用，也就是 <strong class="red">汇编语言 (assembly language)</strong>。</p><ul><li>相应的，机器所能理解的 <code class="blue">二进制语言 (binary language)</code> 就是 <strong class="blue">机器语言 (machine language)</strong>。</li></ul><div class="note info no-icon"><p><span class="red">assembly language</span> : A <code class="purple">symbolic representation</code> of machine instructions.</p><ul><li>汇编语言：机器指令的 <span class="purple">符号表示</span>。</li></ul><p><span class="blue">machine language</span> : A <code class="blue">binary representation</code> of machine instructions.</p><ul><li>机器语言：机器指令的 <span class="blue">二进制表示</span>。</li></ul></div></li></ol><h3 id="高级语言"><a class="anchor" href="#高级语言">#</a> 高级语言</h3><div class="note primary"><p>虽然这是一个巨大的进步，但 <code class="purple">汇编语言</code> 与科学家可能喜欢用来<span class="cyan">模拟流体流动</span>或会计可能用来<span class="purple">平衡账簿</span>的符号仍然相距甚远。</p><ul><li>汇编语言要求程序员为计算机执行的 <code class="blue">每条指令</code> 写一行代码，这迫使程序员 <code class="aqua">像计算机一样思考</code> 。</li><li>人们认识到，可以编写一个 <code class="orange">程序</code> ，将 <code class="red">更强大的语言</code> 翻译成计算机指令，这是计算机早期的重大突破之一。</li></ul></div><ol><li><p>今天的程序员把重获他们的 <span class="cyan">生产力</span>（以及他们的 <span class="aqua">理智</span>）归功于 <span class="blue">高级编程语言</span> 和 <span class="red">编译器</span> 的创造，编译器将这些语言编写的程序翻译成指令。</p></li><li><p><span class="red">编译器</span> 使程序员能够编写这样的 <code class="blue">高级语言</code> 表达式：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>A <span class="token operator">+</span> B</pre></td></tr></table></figure><p>编译器会把它 <span class="purple">编译 (compile)</span> 成下面这个 <code class="aqua">汇编语言</code> 语句：</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>add A,B</pre></td></tr></table></figure><p>如上所示，<span class="cyan">汇编器</span> 将这条语句转换成 <code class="blue">二进制指令</code> ，告诉计算机将 A 和 B 这两个数字相加。</p><div class="note info no-icon"><p><span class="pink">high-level programming language</span> : A <code class="purple">portable language</code> such as C, C++, Java, or Visual Basic that is composed of <code class="aqua">words</code> and <code class="blue">algebraic notation</code> that can be translated by a <code class="red">compiler</code> into <code class="cyan">assembly language</code> .</p><ul><li>高级编程语言：一种<span class="purple">可移植语言</span>，如 C、C++、Java 或 Visual Basic，由<span class="aqua">单词</span>和<span class="blue">代数符号</span>组成，可由<span class="red">编译器</span>翻译成<span class="cyan">汇编语言</span>。</li></ul></div></li><li><p><span class="red">高级编程语言</span> 提供了以下几个重要的好处：</p><ol><li><p>首先，这些高级编程语言允许程序员使用 <code class="blue">更自然的语言</code> 进行思考，使用英语单词和代数符号，从而使程序看起来更像 <code class="aqua">文本 (text)</code> ，而不是神秘符号表。</p><div class="note primary no-icon"><p>此外，高级编程语言允许 <code class="purple">根据语言的预期用途</code> 来设计语言。</p><ul><li>因此，Fortran 是为科学计算而设计的，Cobol 是为业务数据处理而设计的，Lisp 是为符号操作而设计的，等等。</li><li>还有一些特定于领域的语言，甚至适用于更小的用户群体，例如那些对模拟流体感兴趣的用户。</li></ul></div></li><li><p>高级编程语言的第二个优势是提高了程序员的 <span class="aqua">生产力</span>。</p><div class="note info no-icon"><p>在软件开发中，少数几个被广泛认可的领域之一是，如果用需要 <code class="blue">更少的行</code> 来表达一个想法的语言来编写程序，那么开发程序所需的时间就会更少。</p><ul><li><code class="red">简明</code> 是高级语言相对于 <code class="cyan">汇编语言</code> 的明显优势。</li></ul></div></li><li><p>最后一个优点是高级编程语言允许程序 <code class="red">独立于编写它们的计算机</code> ，因为 <code class="aqua">编译器</code> 和 <code class="cyan">汇编器</code> 可以将高级语言程序翻译成 <code class="blue">任何计算机的二进制指令</code> 。</p></li></ol><p>这三个优势是如此强大，以至于今天 <code class="brown">很少有编程</code> 是用 <code class="cyan">汇编语言</code> 完成的。</p></li></ol><ul><li><p>The following shows the relationships among these <code class="cyan">programs</code> and <code class="red">languages</code> , which are more examples of the power of <code class="pink">abstraction</code> .</p><ol><li><p><code class="pink">High-level language program</code> (in C)</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    temp <span class="token operator">=</span> v<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    v<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>The compiler <span class="aqua">compiled</span> the program into assembly language.</p></li><li><p><code class="cyan">Assembly language program</code> (for MIPS)</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token label function">swap:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    multi   <span class="token number">$2</span>, <span class="token number">$5</span>,<span class="token number">4</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    add     <span class="token number">$2</span>, <span class="token number">$4</span>,<span class="token number">$2</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    lw      <span class="token number">$15</span>, <span class="token number">0</span>(<span class="token number">$2</span>)</pre></td></tr><tr><td data-num="5"></td><td><pre>    lw      <span class="token number">$16</span>, <span class="token number">4</span>(<span class="token number">$2</span>)</pre></td></tr><tr><td data-num="6"></td><td><pre>    sw      <span class="token number">$16</span>, <span class="token number">0</span>(<span class="token number">$2</span>)</pre></td></tr><tr><td data-num="7"></td><td><pre>    sw      <span class="token number">$15</span>, <span class="token number">4</span>(<span class="token number">$2</span>)</pre></td></tr><tr><td data-num="8"></td><td><pre>    jr      <span class="token number">$31</span></pre></td></tr></table></figure><p>The assembler then <span class="red">assembled</span> the program into binary machine language.</p></li><li><p><code class="blue">Binary machine language program</code> (for MIPS)</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">00000000101000100000000100011000</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">00000000100000100001000000100001</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">10001101111000100000000000000000</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">10001110000100100000000000000100</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">10101110000100100000000000000000</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">10101101111000100000000000000100</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">00000011111000000000000000001000</span></pre></td></tr></table></figure></li></ol></li><li><p>Although the translation from <span class="pink">high-level language</span> to <span class="blue">binary machine language</span> is shown in <code class="cyan">two steps</code> , some compilers <code class="red">cut out the middleman</code> and produce binary machine language <code class="aqua">directly</code> . These languages and this program are examined in more detail in Chapter 2.</p><ul><li>虽然从<span class="pink">高级语言</span>到<span class="blue">二进制机器语言</span>的转换是分 <code class="cyan">两个步骤</code> 进行的，但有些编译器却 <code class="red">去掉了中间环节</code> ， <code class="aqua">直接生成</code> 二进制机器语言。这些语言和这个程序将在第二章中详细讨论。</li></ul></li></ul><h1 id="外壳之下的硬件under-the-covers"><a class="anchor" href="#外壳之下的硬件under-the-covers">#</a> 外壳之下的硬件（Under the Covers）</h1><div class="tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"><i class="ic i-tag"></i> 计算机组成原理</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-01-08 01:03:51" itemprop="dateModified" datetime="2022-01-08T01:03:51+08:00">2022-01-08</time> </span><span id="computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/" class="item leancloud_visitors" data-flag-title="Chapter 1 Computer Abstractions and Technology" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/images/wechatpay.jpg" alt="Hazuki 叶月 微信支付"><p>微信支付</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Hazuki 叶月 <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://hazuki.cn/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/" title="Chapter 1 Computer Abstractions and Technology">https://hazuki.cn/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/operating-system/Chapter1-Introduction/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;large&#x2F;deef1a0cly8gy127iwzngj21hc0u0126.jpg" title="Chapter 1 Introduction"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 操作系统</span><h3>Chapter 1 Introduction</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%B9%A6"><span class="toc-number">1.1.</span> <span class="toc-text">关于本书</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BA%94%E7%94%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">计算应用的分类及其特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%90%8Epc%E6%97%B6%E4%BB%A3"><span class="toc-number">1.3.</span> <span class="toc-text">欢迎来到后 PC 时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E4%BB%8E%E6%9C%AC%E4%B9%A6%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.</span> <span class="toc-text">你能从本书学到什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%85%AB%E4%B8%AA%E4%BC%9F%E5%A4%A7%E6%80%9D%E6%83%B3"><span class="toc-number">2.</span> <span class="toc-text">计算机体系结构中的八个伟大思想</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B9%8B%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6below-your-program"><span class="toc-number">3.</span> <span class="toc-text">程序之下的软件（Below Your Program）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%88%B0%E7%A1%AC%E4%BB%B6%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">从高级语言到硬件语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%92%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.1.</span> <span class="toc-text">位和指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.2.</span> <span class="toc-text">汇编语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.3.</span> <span class="toc-text">高级语言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%96%E5%A3%B3%E4%B9%8B%E4%B8%8B%E7%9A%84%E7%A1%AC%E4%BB%B6under-the-covers"><span class="toc-number">4.</span> <span class="toc-text">外壳之下的硬件（Under the Covers）</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/" rel="bookmark" title="Chapter 1 Computer Abstractions and Technology">Chapter 1 Computer Abstractions and Technology</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Hazuki 叶月" data-src="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/images/avatar.jpg"><p class="name" itemprop="name">Hazuki 叶月</p><div class="description" itemprop="description">计算机基础 & 编程笔记</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">11</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hhenVraS0yOTU=" title="https:&#x2F;&#x2F;github.com&#x2F;Hazuki-295"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9sdW8tc2hlbmctNzYtMjItMzg=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;luo-sheng-76-22-38"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly95Lm11c2ljLjE2My5jb20vbS91c2VyP2lkPTMwOTUzOTk5NA==" title="https:&#x2F;&#x2F;y.music.163.com&#x2F;m&#x2F;user?id&#x3D;309539994"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链环</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/computer-network/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/computer-science/computer-network/transport-layer/" title="第3章 传输层">第3章 传输层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/" title="分类于 机器学习">机器学习</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/Scikit-learn-Cookbook/" title="分类于 Scikit-learn Cookbook">Scikit-learn Cookbook</a></div><span><a href="/computer-science/machine-learing/Scikit-learn-Cookbook/%E7%AC%AC1%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E9%A2%84%E5%A4%84%E7%90%86/" title="第1章 模型预处理">第1章 模型预处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/computer-network/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/computer-science/computer-network/application-layer/" title="第2章 应用层">第2章 应用层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/" title="分类于 机器学习">机器学习</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/Scikit-learn-Cookbook/" title="分类于 Scikit-learn Cookbook">Scikit-learn Cookbook</a></div><span><a href="/computer-science/machine-learing/Scikit-learn-Cookbook/%E7%AC%AC4%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20scikit-learn%20%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB/" title="第4章 使用 scikit-learn 对数据分类">第4章 使用 scikit-learn 对数据分类</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/operating-system/" title="分类于 操作系统">操作系统</a></div><span><a href="/computer-science/operating-system/Chapter1-Introduction/" title="Chapter 1 Introduction">Chapter 1 Introduction</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 Hexo 博客搭建">Hexo 博客搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/hexo/Theme-Shoka/" title="分类于 Shoka 主题">Shoka 主题</a></div><span><a href="/hexo/Theme.Shoka/01_Shoka/" title="Shoka主题：修改切换标签时更换标题">Shoka主题：修改切换标签时更换标题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/" title="分类于 机器学习">机器学习</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/Scikit-learn-Cookbook/" title="分类于 Scikit-learn Cookbook">Scikit-learn Cookbook</a></div><span><a href="/computer-science/machine-learing/Scikit-learn-Cookbook/%E7%AC%AC3%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/" title="第3章 使用距离向量构建模型">第3章 使用距离向量构建模型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/" title="分类于 机器学习">机器学习</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/machine-learing/Scikit-learn-Cookbook/" title="分类于 Scikit-learn Cookbook">Scikit-learn Cookbook</a></div><span><a href="/computer-science/machine-learing/Scikit-learn-Cookbook/%E7%AC%AC5%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E5%90%8E%E5%A4%84%E7%90%86/" title="第5章 模型后处理">第5章 模型后处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/computer-network/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/computer-science/computer-network/network-layer-1/" title="第4章 网络层：数据平面">第4章 网络层：数据平面</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/computer-organization/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/" title="Chapter 1 Computer Abstractions and Technology">Chapter 1 Computer Abstractions and Technology</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Hazuki 叶月 @ Hazuki の 小屋</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">177k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:41</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/computer-organization/Chapter1-Computer-Abstractions-and-Technology/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/Hazuki-295/Hazuki-295.github.io@v1.0.5/js/app.js?v=0.2.5"></script></body></html>